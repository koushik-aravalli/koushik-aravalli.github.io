{"componentChunkName":"component---src-templates-blog-post-js","path":"/AzureFunction-Turnkey-Authorization/","result":{"data":{"site":{"siteMetadata":{"title":"Koushik's scribble"}},"markdownRemark":{"id":"2344f412-575f-52c5-b1c4-22e471b9f12d","excerpt":"Working with Azure Functions as typical API When Azure functions were launched in January 2017, it was fascinating to see how easy it is to copy bits of of code…","html":"<!-- Post Content -->\n<br/>\n<h2>Working with Azure Functions as typical API</h2>\n<p>When Azure functions were launched in January 2017, it was fascinating to see how easy it is to copy bits of of code. Honestly, I used it for testing code behavior rather than utilizing it to the most. And during the same year in June, talking to the Product team at Integrate 2017, some fantastic use cases were unveiled lighting up few bulbs in my head.</p>\n<p>While enterprises chase the dream to APIfy all their products, cloud service providers speedup the innovations.</p>\n<h2>Problem Statement</h2>\n<p>The APIs are defined and published across organization to be consumed by Authorized groups. Although App Service Authentication can be managed within Azure (Portal/PS/CLI), the challenge is to have authorization set. How are these tackled to minimize the risk of cross teams breaching into private data sets.</p>\n<p>Here is the illustration of what we are trying to solve\n<img src=\"../../assetsAuthroized-AzFunction.jpg\"></p>\n<h2>Turn Key solution</h2>\n<p>Within <strong><a href=\"https://docs.microsoft.com/en-us/azure/app-service/app-service-authentication-how-to\">Azure docs</a></strong>, highlights the usage of Turn-Key approach to address the Authorization issue. </p>\n<p>Here is the prerequisite:</p>\n<ol>\n<li>Create an Azure FunctionApp and Add Authentication by registering it in the AzureAD</li>\n<li>Assume there are two Azure AD groups, if not create, and multiple users or ServicePrincipal in each group</li>\n<li>Select one of the two ADGroup members are only allowed to consume the FunctionApp API</li>\n<li>As FunctionApp is invoked, request header ‘Authorization’ should be added with Bearer token</li>\n<li>Before calling the Function within the FunctionApp, invoke a service within the pipeline to perform authorization</li>\n</ol>\n<h3>Within Authorization Service - high level overview of the process</h3>\n<ol>\n<li>Read and capture the incoming request header token</li>\n<li>Read and capture, user context</li>\n<li>Get claims for the incoming user context, e.g. ObjectId, TenantId, Name</li>\n<li>Using GraphAPI, GET AD Group memberships linked to the ObjectId</li>\n<li>Check if the selected ADGroup which is allowed to consume the Function is part of the ObjectId membership list.</li>\n</ol>\n<h2>V3 of Azure Function: What does it mean?</h2>\n<p>It is almost a day in day out work to write, publish and deploy APIs as developers and architects (yes they do write code). .NET Core is a norm, if you do not believe it look in the <strong><a href=\"https://insights.stackoverflow.com/survey/2019#technology-_-other-frameworks-libraries-and-tools\">stackoverflow’s statistics</a></strong>. </p>\n<p>Azure Function with the .NET core starting from V2 version supports Dependency Injection. And V3, launched in September 2019, is implemented with .NET 3.1 </p>\n<h2>Enough scribbling… code please</h2>\n<p>If you jumped here, you have not missed anything about awesomeness of .NET core and Azure Function.</p>\n<p>So where do we start…</p>\n<h3>For the prerequisites</h3>\n<p><strong><a href=\"https://docs.microsoft.com/en-us/azure/app-service/configure-authentication-provider-aad\">Azure Docs</a></strong> provides details on how to create Authentication on an App Service. </p>\n<h4>We want code… no portal</h4>\n<p>When using ARM template it can also be done with the following resource added to the FunctionApp deployment:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"parameters\":{\n    \"authenticationClientSecret\": {\n        \"reference\": {\n          \"keyVault\": {\n          \"id\": \"/subscriptions/&lt;subscription-id>/resourceGroups/&lt;rg-name>/providers/Microsoft.KeyVault/vaults/&lt;vault-name>\"\n          },\n          \"secretName\": \"authenticationClientSecret\"\n        }\n      },\n    \"authenticationClientId\": {\n        \"reference\": {\n          \"keyVault\": {\n          \"id\": \"/subscriptions/&lt;subscription-id>/resourceGroups/&lt;rg-name>/providers/Microsoft.KeyVault/vaults/&lt;vault-name>\"\n          },\n          \"secretName\": \"authenticationClientId\"\n        }\n      }\n  },\n  \"variables\" : {\n    \"authenticationTokenIssuer\": \"https://sts.windows.net/&lt;tenant-id>\"\n  }\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  {\n      \"type\": \"config\",\n      \"name\": \"authsettings\",\n      \"apiVersion\": \"2019-08-01\",\n      \"dependsOn\": [\n          \"[variables('appServiceResourceId')]\"\n      ],\n      \"properties\": {\n          \"enabled\": true,\n          \"unauthenticatedClientAction\": \"RedirectToLoginPage\",\n          \"tokenStoreEnabled\": true,\n          \"defaultProvider\": \"AzureActiveDirectory\",\n          \"clientId\": \"[parameters('authenticationClientId')]\",\n          \"clientSecret\": \"[parameters('authenticationClientSecret')]\",\n          \"issuer\": \"[variables('authenticationTokenIssuer')]\",\n          \"additionalLoginParams\": [\n              \"response_type=code id_token\",\n              \"resource=https://graph.windows.net\"\n          ],\n          \"allowedAudiences\": [\n              \"https://graph.windows.net\"\n          ]\n      }\n  }</code></pre></div>\n<p>Validate SPN’s API permission after the FunctionApp deployment\n<img src=\"../../assetsfunctionapp-spn-app-permissions.jpg\"></p>\n<p>In this example Azure Function ‘its-authenticated’ is deployed in ‘pass-workload’ resource group.</p>\n<h4>Check delegated SPN</h4>\n<p>After this step, from azure cloud shell get the dedicated service principal of the FunctionApp</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  az webapp auth show --name 'its-authenticated' --resource-group 'paas-workload'</code></pre></div>\n<p>From the response, get clientId.</p>\n<h4>Create AAD Group</h4>\n<ul>\n<li>\n<p>AAD group who are allowed to consume Functions within Azure FunctionApp</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">az ad group create --display-name DevOpsTeamOne --mail-nickname devopsteam-one</code></pre></div>\n</li>\n<li>\n<p>AAD group who are not allowed to consume Functions within Azure FunctionApp</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">az ad group create --display-name DevOpsTeamTwo --mail-nickname devopsteam-two</code></pre></div>\n</li>\n</ul>\n<h4>Add member to AAD Group</h4>\n<ul>\n<li>\n<p>Add clientId (SPN) of the FunctionApp to the authorized AAD group</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">az ad group member add --group DevOpsTeamOne --member-id $client_id</code></pre></div>\n</li>\n<li>\n<p>Add <em>sampleuser</em> to the unauthorized AAD group</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">az ad group member add --group DevOpsTeamTwo --member-id ${objectid_of_user}</code></pre></div>\n</li>\n</ul>\n<h4>Get access-token for a user</h4>\n<ul>\n<li>Login as the ServicePrincipal <strong><a href=\"#check-delegated-spn\">client_secret value is part of the command</a></strong></li>\n<li>\n<p>Run Azure cli command to get the token</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">az account get-access-token</code></pre></div>\n</li>\n</ul>\n<h4>Decode token</h4>\n<p>To check if the token belongs to the expected Tenant and is a valid user. You can also decode the token using <strong><a href=\"https://jwt.io/#encoded-jwt\">jwt.io</a></strong> and check manually</p>\n<p>Here is the sample code to get details using Azure AD GraphApi:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  string aadObjectUrl = $\"https://graph.windows.net/{TenantId}/directoryObjects/{incommingClientObjectId}?api-version=1.6\";\n  using (var aadObjectResponse = await _client.GetAsync(aadObjectUrl))\n  {\n      string objectContent = await aadObjectResponse.Content.ReadAsStringAsync();\n      aadObjectResponse.EnsureSuccessStatusCode();\n\n      dynamic aadObject = JsonConvert.DeserializeObject(objectContent);\n      if (aadObject.ObjectType == \"ServicePrincipal\")\n      {\n          principalDataRsp.DisplayName = $\"{aadObject.DisplayName} ({aadObject.AppId})\";\n      }\n\n      _log.LogInformation($\"Called by '{principalDataRsp.DisplayName}' with object id '{principalDataRsp.ObjectId}' and tenant id '{principalDataRsp.TenantId}'.\");\n\n  }</code></pre></div>\n<p>  <em>Note: HttpClient is initialized with default authorization headers as the incoming accesstoken.</em></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", accessToken);</code></pre></div>\n<h4>Get Group Memberships of the current user context</h4>\n<p>Again using AzureAD graph API get all group membership that the user context has. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  string memberGroupsUrl = $\"https://graph.windows.net/{TenantId}/directoryObjects/{incommingClientObjectId}/getMemberGroups?api-version=1.6\";\n  HttpContent postContent = new StringContent(\"{ \\\"securityEnabledOnly\\\": true }\", Encoding.UTF8, \"application/json\");\n  using (var membersGroupResponse = await _client.PostAsync(memberGroupsUrl, postContent))\n  {\n      membersGroupResponse.EnsureSuccessStatusCode();\n\n      string membersGroupContent = await membersGroupResponse.Content.ReadAsStringAsync();\n\n      JsonDocument json = JsonDocument.Parse(membersGroupContent);\n      JsonElement valueElement = json.RootElement.GetProperty(\"value\");\n      bool authorizedGroupFound = false;\n      int numberOfGroups = valueElement.GetArrayLength();\n      _log.LogInformation($\"Found {numberOfGroups} groups of which the service principal '{principalDataRsp.DisplayName}' is a member.\");\n\n  }</code></pre></div>\n<h4>Finally check if the list has valid Authorized group</h4>\n<p>Use LINQ or normal conditional loop</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  foreach (JsonElement arrayElement in valueElement.EnumerateArray())\n  {\n      if (arrayElement.GetString() == AuthorizedGroupObjectId)\n      {\n          authorizedGroupFound = true;\n          break;\n      }\n  }</code></pre></div>\n<p>That’s it.. ;) … Hope that gives a starting point to secure Azure FunctionApp.. Here is the <strong><a href=\"https://github.com/koushik-aravalli/functionapp-dotnetcore\">repo</a></strong> for reference</p>","frontmatter":{"title":"Azure Function with Turnkey Authorization","date":"June 22, 2020","description":"","tags":["azure","functionapp"]}}},"pageContext":{"slug":"/AzureFunction-Turnkey-Authorization/","previous":{"fields":{"slug":"/github-vscode-error/"},"frontmatter":{"title":"Clone GitHub Repo from VSCode"}},"next":{"fields":{"slug":"/about-me/"},"frontmatter":{"title":"About me"}}}},"staticQueryHashes":["2841359383"]}