{"componentChunkName":"component---src-templates-blog-post-js","path":"/Building-AzureDevOps-PipelineExtension/","result":{"data":{"site":{"siteMetadata":{"title":"Koushik's scribble"}},"markdownRemark":{"id":"dbf0aa9c-d85d-5e1e-8e56-b9f0239190a5","excerpt":"Why are we talking about building custom extension? To meet one or more objectives of a CCoE, out-of-box Azure Resources (Service) are deployed with preapprovedâ€¦","html":"<!-- Post Content -->\n<br/>\n<h2>Why are we talking about building custom extension?</h2>\n<p>To meet one or more <strong><em><a href=\"https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/organize/cloud-center-of-excellence#key-responsibilities\">objectives of a CCoE</a></em></strong>, out-of-box Azure Resources (Service) are deployed with preapproved configuration sets, security controls and organization standards. Therefore, a need arises to box the required solution into one package which is reusable, idempotent and consistent across all working teams. </p>\n<p>When working with Azure, infrastructure is provisioned using Azure Resource Manager <em>(basically an API)</em>. ARM Templates, Azure CLI or Terraform are tools which interface with this API to provision any required Azure service. </p>\n<p>DevOps and DevSecOps are already well known terms and are used in conjunction with automation in an application architecture. <em>Azure DevOps</em> is one of the proven DevOps tool which is also customizable. Automating the infrastructure deployment (Infra-as-code) on Azure with Azure DevOps is a potential solution towards achieving the objectives. </p>\n<h2>What are the steps to build an extension</h2>\n<p>An Extension adds new capabilities to Azure DevOps environment. These capabilities are termed as <strong><em>Contributions</em></strong>. A Contribution can be of type <code class=\"language-text\">hub</code>, <code class=\"language-text\">action</code>, <code class=\"language-text\">build-task</code> which is a unit of work or a building block that makes a pipeline. </p>\n<p>To build an extension with one or more tasks:\nUsing simple ARM deployment, lets build an Azure DevOps Extension in 5 steps.</p>\n<p><strong><em>Step 1</em></strong>: PowerShell script with Azure Modules invoking ARM template</p>\n<p><strong><em>Step 2</em></strong>: Download To wrap the scripts as an extension, download the dependent modules (more like SDKs) from <a href=\"https://github.com/microsoft/azure-pipelines-tasks/tree/master/Tasks/Common\">Azure DevOps GitHub</a>, Save it to folder <code class=\"language-text\">ps_modules</code>. (Yes the name should be exactly that!!)\n* VstsTaskSDK\n* VstsAzureRestHelper\n* VstsAzureHelper\n* TlsHelper (Common library handling security)</p>\n<p><strong><em>Step 3</em></strong>: Create entry point by adding Invoke script - <code class=\"language-text\">main.ps1</code>. User input is captured using <code class=\"language-text\">Get-VstsInput</code>, a parameter object is created to fulfil the ARM template requirements. </p>\n<p><em>In case RestAPI is used instead of ARM templates, POST operation payload can also be gathered as input.</em></p>\n<p><strong><em>Step 4</em></strong>: Make this as task. Task acts an interface to collect required information (Parameters).. consider it as a UI. Add <code class=\"language-text\">task.json</code>. </p>\n<p><code class=\"language-text\">task.json main.ps1</code> bridges across user and the script that were created in first step. </p>\n<p><strong><em>Step 5</em></strong>: Wrap every thing into an Extension - <code class=\"language-text\">vss-extension.json</code>\n* Take ownership by assigning it to an Organization\n* Embed tasks\n* Beautify it with icon</p>\n<h2>Test your extension - Locally</h2>\n<p><strong><em>Step 1</em></strong>: Import required Azure Modules <code class=\"language-text\">Import-Module Az</code></p>\n<p><strong><em>Step 2</em></strong>: Import VstsSdk Module <code class=\"language-text\">Import-Module .\\ps_modules\\VstsTaskSdk\\VstsTaskSdk.psd1 -Global</code></p>\n<p><strong><em>Step 3</em></strong>: Get Azure context <code class=\"language-text\">Login-AzAccoount</code> </p>\n<p><strong><em>Step 4</em></strong>: Execute entry point script <code class=\"language-text\">main.ps1</code>. During execution, each input will be prompted in the attached terminal.</p>\n<p><em>Note - Since Azure Context is already provided at Step 3, Ignore the values for <code class=\"language-text\">ConnectedServiceNameSelector</code>, <code class=\"language-text\">ConnectedServiceName</code>, <code class=\"language-text\">Service Endpoint Url</code> can be left empty. Safely ignore the pop out log errors</em> </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">##vso[task.logissue type=error]Required: '' service endpoint URL\n##vso[task.logissue type=error]Cannot bind argument to parameter 'Endpoint' because it is null.</code></pre></div>\n<p><strong><em>Step 5</em></strong>: Login to Azure and validate deployed resource if it meets the required controls</p>\n<h2>Package and Publish - Locally</h2>\n<p>TFS cli (tfx) is offered as an npm package. To perform actions locally, NodeJS installation is a requirement.</p>\n<p><strong><em>Package</em></strong>: Navigate to the extension directory. </p>\n<p><code class=\"language-text\">tfx extension create --manifests vss-extension.json</code></p>\n<p><strong><em>Publish</em></strong>: </p>\n<p><code class=\"language-text\">tfx extension create --manifests vss-extension.json</code></p>\n<h2>Package and Publish - Pipeline</h2>\n<p>As the number of custom extensions grow, having the entire deployment cycle with Querying latest extension, Packaging the extension and Publishing the extension will be redundant. And more importantly, automating the extension publishing remove the overhead of manual interactions. </p>\n<p>Here is the Job template to publish extension in an Azure DevOps Organization</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{% raw %}\n## Deploy Extension Job Template\n\nparameters:\n  extension_name: ''\n  extension_path: ''\n  service_connection: ''\n\njobs:\n- job: \"Deploy_Extension\"\n  pool:\n    vm_image: windows-latest\n  variables:\n    Extension.Name: ${{ parameters.extension_name }}\n  steps:\n    - task: ms-devlabs.vsts-developer-tools-build-tasks.extension-version-build-task.QueryAzureDevOpsExtensionVersion@2\n      displayName: 'Query Extension Version'\n      inputs:\n        connectedServiceName: ${{parameters.service_connection}}\n        publisherId: Koushik-Aravalli ## Change accordingly, publisherId doesnt seem to support variablization\n        extensionId: $(Extension.Name)\n        versionAction: Patch\n        outputVariable: QueryExtension.Version\n        extensionVersionOverride: QueryExtension.VersionOverride\n\n    - task: ms-devlabs.vsts-developer-tools-build-tasks.package-extension-build-task.PackageAzureDevOpsExtension@2\n      displayName: 'Package Extension'\n      inputs:\n        rootFolder: ${{ parameters.extension_path }}\n        outputPath: output/vstspackage.vsix\n        extensionVersion: '$(QueryExtension.Version)'\n        updateTasksVersion: true\n        updateTasksVersionType: patch\n        extensionVisibility: private\n        outputVariable: CreateExtension.OutputPath\n\n    - task: PublishBuildArtifacts@1\n      displayName: 'Publish Artifact: output'\n      inputs:\n        PathtoPublish: \"$(CreateExtension.OutputPath)\"\n        ArtifactName: output\n\n    - task: ms-devlabs.vsts-developer-tools-build-tasks.publish-extension-build-task.PublishAzureDevOpsExtension@2\n      displayName: 'Publish Extension'\n      inputs:\n        connectedServiceName: ${{ parameters.service_connection }}\n        fileType: vsix\n        vsixFile: $(CreateExtension.OutputPath)\n        publisherId: Koushik-Aravalli ## Change accordingly, publisherId doesnt seem to support variablization\n        extensionId: $(Extension.Name)\n        extensionName: $(Extension.Name)\n        updateTasksVersion: false\n{% endraw %}</code></pre></div>\n<p>Invoke the template</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">## Extension deployment pipeline\n\nvariables:\n    extension_name: 'sample-extension'\n    extension_location: 'SampleExtension' # Name of the extension root folder\njobs:\n  - template: deploy-extension.yaml\n    parameters:\n      extension_name: $(extension_name)\n      extension_path: $(extension_location)\n      service_connection: \"azdevops-extension-spn\"</code></pre></div>\n<p>Here is the <strong><em><a href=\"https://github.com/koushik-aravalli/azuredevops-pipeline-extension\">extension code</a></em></strong></p>","frontmatter":{"title":"Building AzureDevOps PipelineExtension","date":"July 13, 2021","description":"","tags":["azure-devops","extension"]}}},"pageContext":{"slug":"/Building-AzureDevOps-PipelineExtension/","previous":{"fields":{"slug":"/CKAD-preparation/2021-05-08-CKAD-PodLifecycle/"},"frontmatter":{"title":"CKAD Preparation - Pod Life cycle"}},"next":{"fields":{"slug":"/AzureDevOps-Extension-CanaryModel/"},"frontmatter":{"title":"AzureDevOps Extension Canary deployed backed API"}}}},"staticQueryHashes":["2841359383"]}